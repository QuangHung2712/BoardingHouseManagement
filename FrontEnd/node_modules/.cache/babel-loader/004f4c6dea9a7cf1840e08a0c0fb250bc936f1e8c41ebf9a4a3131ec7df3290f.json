{"ast":null,"code":"import { createWebHistory, createRouter } from \"vue-router\";\nimport routes from './routes';\nimport appConfig from \"../../app.config\";\nimport store from \"../state/store\";\nconst router = createRouter({\n  history: createWebHistory(\"/vue/\"),\n  routes\n});\nrouter.beforeResolve(async (routeTo, routeFrom, next) => {\n  // Tạo một hook `BeforeResolve`, nó sẽ kích hoạt bất cứ khi nào\n  // `BeforeRouteEnter` và `BeforeRouteUpdate` sẽ. Cái này\n  // Cho phép chúng tôi đảm bảo dữ liệu được tìm nạp ngay cả khi thông số thay đổi,\n  // Nhưng tuyến đường đã giải quyết thì không. Chúng tôi đặt nó trong `meta` để\n  // Chỉ ra rằng đó là một hook mà chúng ta đã tạo ra, chứ không phải là một phần của\n  // Bộ định tuyến Vue (chưa?).\n  try {\n    // Đối với mỗi tuyến đường phù hợp...\n    for (const route of routeTo.matched) {\n      await new Promise((resolve, reject) => {\n        // If a `beforeResolve` hook is defined, call it with\n        // the same arguments as the `beforeEnter` hook.\n        if (route.meta && route.meta.beforeResolve) {\n          route.meta.beforeResolve(routeTo, routeFrom, (...args) => {\n            // If the user chose to redirect...\n            if (args.length) {\n              // If redirecting to the same route we're coming from...\n              // Complete the redirect.\n              next(...args);\n              reject(new Error('Redirected'));\n            } else {\n              resolve();\n            }\n          });\n        } else {\n          // Otherwise, continue resolving the route.\n          resolve();\n        }\n      });\n    }\n    // If a `beforeResolve` hook chose to redirect, just return.\n  } catch (error) {\n    return;\n  }\n  document.title = routeTo.meta.title + ' | ' + appConfig.title;\n  // If we reach this point, continue resolving the route.\n  next();\n});\nrouter.beforeEach((to, from, next) => {\n  // Kiểm tra nếu route yêu cầu đăng nhập\n  if (to.meta.requiresAuth) {\n    const isAuthenticated = store.getters['isAuthenticated']; // Kiểm tra trạng thái đăng nhập từ Vuex hoặc localStorage\n\n    if (isAuthenticated) {\n      next(); // Đã đăng nhập, cho phép truy cập\n    } else {\n      next({\n        name: 'login'\n      }); // Chuyển hướng tới trang đăng nhập\n    }\n  } else {\n    next(); // Không yêu cầu đăng nhập, cho phép truy cập\n  }\n});\nexport default router;","map":{"version":3,"names":["createWebHistory","createRouter","routes","appConfig","store","router","history","beforeResolve","routeTo","routeFrom","next","route","matched","Promise","resolve","reject","meta","args","length","Error","error","document","title","beforeEach","to","from","requiresAuth","isAuthenticated","getters","name"],"sources":["D:/Code/BoardingHouseManagement/BoardingHouseManagement/FrontEnd/src/router/index.js"],"sourcesContent":["import { createWebHistory, createRouter } from \"vue-router\";\r\nimport routes from './routes';\r\nimport appConfig from \"../../app.config\";\r\nimport store from \"../state/store\";\r\n\r\n\r\nconst router = createRouter({\r\n    history: createWebHistory(\"/vue/\"),\r\n    routes,\r\n  \r\n});\r\n\r\nrouter.beforeResolve(async (routeTo, routeFrom, next) => {\r\n    // Tạo một hook `BeforeResolve`, nó sẽ kích hoạt bất cứ khi nào\r\n    // `BeforeRouteEnter` và `BeforeRouteUpdate` sẽ. Cái này\r\n    // Cho phép chúng tôi đảm bảo dữ liệu được tìm nạp ngay cả khi thông số thay đổi,\r\n    // Nhưng tuyến đường đã giải quyết thì không. Chúng tôi đặt nó trong `meta` để\r\n    // Chỉ ra rằng đó là một hook mà chúng ta đã tạo ra, chứ không phải là một phần của\r\n    // Bộ định tuyến Vue (chưa?).\r\n    try {\r\n        // Đối với mỗi tuyến đường phù hợp...\r\n        for (const route of routeTo.matched) {\r\n            await new Promise((resolve, reject) => {\r\n                // If a `beforeResolve` hook is defined, call it with\r\n                // the same arguments as the `beforeEnter` hook.\r\n                if (route.meta && route.meta.beforeResolve) {\r\n                    route.meta.beforeResolve(routeTo, routeFrom, (...args) => {\r\n                        // If the user chose to redirect...\r\n                        if (args.length) {\r\n                            // If redirecting to the same route we're coming from...\r\n                            // Complete the redirect.\r\n                            next(...args);\r\n                            reject(new Error('Redirected'));\r\n                        } else {\r\n                            resolve();\r\n                        }\r\n                    });\r\n                } else {\r\n                    // Otherwise, continue resolving the route.\r\n                    resolve();\r\n                }\r\n            });\r\n        }\r\n        // If a `beforeResolve` hook chose to redirect, just return.\r\n    } catch (error) {\r\n        return;\r\n    }\r\n    document.title = routeTo.meta.title + ' | ' + appConfig.title;\r\n    // If we reach this point, continue resolving the route.\r\n    next();\r\n});\r\nrouter.beforeEach((to, from, next) => {\r\n    // Kiểm tra nếu route yêu cầu đăng nhập\r\n    if (to.meta.requiresAuth) {\r\n        const isAuthenticated = store.getters['isAuthenticated']; // Kiểm tra trạng thái đăng nhập từ Vuex hoặc localStorage\r\n        \r\n        if (isAuthenticated) {\r\n            next(); // Đã đăng nhập, cho phép truy cập\r\n        } else {\r\n            next({ name: 'login' }); // Chuyển hướng tới trang đăng nhập\r\n        }\r\n    } else {\r\n        next(); // Không yêu cầu đăng nhập, cho phép truy cập\r\n    }\r\n});\r\n\r\nexport default router;"],"mappings":"AAAA,SAASA,gBAAgB,EAAEC,YAAY,QAAQ,YAAY;AAC3D,OAAOC,MAAM,MAAM,UAAU;AAC7B,OAAOC,SAAS,MAAM,kBAAkB;AACxC,OAAOC,KAAK,MAAM,gBAAgB;AAGlC,MAAMC,MAAM,GAAGJ,YAAY,CAAC;EACxBK,OAAO,EAAEN,gBAAgB,CAAC,OAAO,CAAC;EAClCE;AAEJ,CAAC,CAAC;AAEFG,MAAM,CAACE,aAAa,CAAC,OAAOC,OAAO,EAAEC,SAAS,EAAEC,IAAI,KAAK;EACrD;EACA;EACA;EACA;EACA;EACA;EACA,IAAI;IACA;IACA,KAAK,MAAMC,KAAK,IAAIH,OAAO,CAACI,OAAO,EAAE;MACjC,MAAM,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;QACnC;QACA;QACA,IAAIJ,KAAK,CAACK,IAAI,IAAIL,KAAK,CAACK,IAAI,CAACT,aAAa,EAAE;UACxCI,KAAK,CAACK,IAAI,CAACT,aAAa,CAACC,OAAO,EAAEC,SAAS,EAAE,CAAC,GAAGQ,IAAI,KAAK;YACtD;YACA,IAAIA,IAAI,CAACC,MAAM,EAAE;cACb;cACA;cACAR,IAAI,CAAC,GAAGO,IAAI,CAAC;cACbF,MAAM,CAAC,IAAII,KAAK,CAAC,YAAY,CAAC,CAAC;YACnC,CAAC,MAAM;cACHL,OAAO,CAAC,CAAC;YACb;UACJ,CAAC,CAAC;QACN,CAAC,MAAM;UACH;UACAA,OAAO,CAAC,CAAC;QACb;MACJ,CAAC,CAAC;IACN;IACA;EACJ,CAAC,CAAC,OAAOM,KAAK,EAAE;IACZ;EACJ;EACAC,QAAQ,CAACC,KAAK,GAAGd,OAAO,CAACQ,IAAI,CAACM,KAAK,GAAG,KAAK,GAAGnB,SAAS,CAACmB,KAAK;EAC7D;EACAZ,IAAI,CAAC,CAAC;AACV,CAAC,CAAC;AACFL,MAAM,CAACkB,UAAU,CAAC,CAACC,EAAE,EAAEC,IAAI,EAAEf,IAAI,KAAK;EAClC;EACA,IAAIc,EAAE,CAACR,IAAI,CAACU,YAAY,EAAE;IACtB,MAAMC,eAAe,GAAGvB,KAAK,CAACwB,OAAO,CAAC,iBAAiB,CAAC,CAAC,CAAC;;IAE1D,IAAID,eAAe,EAAE;MACjBjB,IAAI,CAAC,CAAC,CAAC,CAAC;IACZ,CAAC,MAAM;MACHA,IAAI,CAAC;QAAEmB,IAAI,EAAE;MAAQ,CAAC,CAAC,CAAC,CAAC;IAC7B;EACJ,CAAC,MAAM;IACHnB,IAAI,CAAC,CAAC,CAAC,CAAC;EACZ;AACJ,CAAC,CAAC;AAEF,eAAeL,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}